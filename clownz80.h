#ifndef CLOWNZ80_H
#define CLOWNZ80_H

/* If enabled, a lookup table is used to optimise opcode decoding. Disable this to save RAM. */
#define CLOWNZ80_PRECOMPUTE_INSTRUCTION_METADATA

#include "clowncommon/clowncommon.h"

typedef enum ClownZ80_Opcode
{
	CLOWNZ80_OPCODE_NOP,
	CLOWNZ80_OPCODE_EX_AF_AF,
	CLOWNZ80_OPCODE_DJNZ,
	CLOWNZ80_OPCODE_JR_UNCONDITIONAL,
	CLOWNZ80_OPCODE_JR_CONDITIONAL,
	CLOWNZ80_OPCODE_LD_16BIT,
	CLOWNZ80_OPCODE_ADD_HL,
	CLOWNZ80_OPCODE_LD_8BIT,
	CLOWNZ80_OPCODE_INC_16BIT,
	CLOWNZ80_OPCODE_DEC_16BIT,
	CLOWNZ80_OPCODE_INC_8BIT,
	CLOWNZ80_OPCODE_DEC_8BIT,
	CLOWNZ80_OPCODE_RLCA,
	CLOWNZ80_OPCODE_RRCA,
	CLOWNZ80_OPCODE_RLA,
	CLOWNZ80_OPCODE_RRA,
	CLOWNZ80_OPCODE_DAA,
	CLOWNZ80_OPCODE_CPL,
	CLOWNZ80_OPCODE_SCF,
	CLOWNZ80_OPCODE_CCF,
	CLOWNZ80_OPCODE_HALT,
	CLOWNZ80_OPCODE_ADD_A,
	CLOWNZ80_OPCODE_ADC_A,
	CLOWNZ80_OPCODE_SUB,
	CLOWNZ80_OPCODE_SBC_A,
	CLOWNZ80_OPCODE_AND,
	CLOWNZ80_OPCODE_XOR,
	CLOWNZ80_OPCODE_OR,
	CLOWNZ80_OPCODE_CP,
	CLOWNZ80_OPCODE_RET_CONDITIONAL,
	CLOWNZ80_OPCODE_POP,
	CLOWNZ80_OPCODE_RET_UNCONDITIONAL,
	CLOWNZ80_OPCODE_EXX,
	CLOWNZ80_OPCODE_JP_HL,
	CLOWNZ80_OPCODE_LD_SP_HL,
	CLOWNZ80_OPCODE_JP_CONDITIONAL,
	CLOWNZ80_OPCODE_JP_UNCONDITIONAL,
	CLOWNZ80_OPCODE_CB_PREFIX,
	CLOWNZ80_OPCODE_OUT,
	CLOWNZ80_OPCODE_IN,
	CLOWNZ80_OPCODE_EX_SP_HL,
	CLOWNZ80_OPCODE_EX_DE_HL,
	CLOWNZ80_OPCODE_DI,
	CLOWNZ80_OPCODE_EI,
	CLOWNZ80_OPCODE_CALL_CONDITIONAL,
	CLOWNZ80_OPCODE_PUSH,
	CLOWNZ80_OPCODE_CALL_UNCONDITIONAL,
	CLOWNZ80_OPCODE_DD_PREFIX,
	CLOWNZ80_OPCODE_ED_PREFIX,
	CLOWNZ80_OPCODE_FD_PREFIX,
	CLOWNZ80_OPCODE_RST,
	CLOWNZ80_OPCODE_RLC,
	CLOWNZ80_OPCODE_RRC,
	CLOWNZ80_OPCODE_RL,
	CLOWNZ80_OPCODE_RR,
	CLOWNZ80_OPCODE_SLA,
	CLOWNZ80_OPCODE_SRA,
	CLOWNZ80_OPCODE_SLL,
	CLOWNZ80_OPCODE_SRL,
	CLOWNZ80_OPCODE_BIT,
	CLOWNZ80_OPCODE_RES,
	CLOWNZ80_OPCODE_SET,
	CLOWNZ80_OPCODE_IN_REGISTER,
	CLOWNZ80_OPCODE_IN_NO_REGISTER,
	CLOWNZ80_OPCODE_OUT_REGISTER,
	CLOWNZ80_OPCODE_OUT_NO_REGISTER,
	CLOWNZ80_OPCODE_SBC_HL,
	CLOWNZ80_OPCODE_ADC_HL,
	CLOWNZ80_OPCODE_NEG,
	CLOWNZ80_OPCODE_RETN,
	CLOWNZ80_OPCODE_RETI,
	CLOWNZ80_OPCODE_IM,
	CLOWNZ80_OPCODE_LD_I_A,
	CLOWNZ80_OPCODE_LD_R_A,
	CLOWNZ80_OPCODE_LD_A_I,
	CLOWNZ80_OPCODE_LD_A_R,
	CLOWNZ80_OPCODE_RRD,
	CLOWNZ80_OPCODE_RLD,
	CLOWNZ80_OPCODE_LDI,
	CLOWNZ80_OPCODE_LDD,
	CLOWNZ80_OPCODE_LDIR,
	CLOWNZ80_OPCODE_LDDR,
	CLOWNZ80_OPCODE_CPI,
	CLOWNZ80_OPCODE_CPD,
	CLOWNZ80_OPCODE_CPIR,
	CLOWNZ80_OPCODE_CPDR,
	CLOWNZ80_OPCODE_INI,
	CLOWNZ80_OPCODE_IND,
	CLOWNZ80_OPCODE_INIR,
	CLOWNZ80_OPCODE_INDR,
	CLOWNZ80_OPCODE_OUTI,
	CLOWNZ80_OPCODE_OUTD,
	CLOWNZ80_OPCODE_OTIR,
	CLOWNZ80_OPCODE_OTDR
} ClownZ80_Opcode;

typedef enum ClownZ80_Operand
{
	CLOWNZ80_OPERAND_NONE,
	CLOWNZ80_OPERAND_A,
	CLOWNZ80_OPERAND_B,
	CLOWNZ80_OPERAND_C,
	CLOWNZ80_OPERAND_D,
	CLOWNZ80_OPERAND_E,
	CLOWNZ80_OPERAND_H,
	CLOWNZ80_OPERAND_L,
	CLOWNZ80_OPERAND_IXH,
	CLOWNZ80_OPERAND_IXL,
	CLOWNZ80_OPERAND_IYH,
	CLOWNZ80_OPERAND_IYL,
	CLOWNZ80_OPERAND_AF,
	CLOWNZ80_OPERAND_BC,
	CLOWNZ80_OPERAND_DE,
	CLOWNZ80_OPERAND_HL,
	CLOWNZ80_OPERAND_IX,
	CLOWNZ80_OPERAND_IY,
	CLOWNZ80_OPERAND_PC,
	CLOWNZ80_OPERAND_SP,
	CLOWNZ80_OPERAND_BC_INDIRECT,
	CLOWNZ80_OPERAND_DE_INDIRECT,
	CLOWNZ80_OPERAND_HL_INDIRECT,
	CLOWNZ80_OPERAND_IX_INDIRECT,
	CLOWNZ80_OPERAND_IY_INDIRECT,
	CLOWNZ80_OPERAND_ADDRESS,
	CLOWNZ80_OPERAND_LITERAL_8BIT,
	CLOWNZ80_OPERAND_LITERAL_16BIT
} ClownZ80_Operand;

typedef enum ClownZ80_Condition
{
	CLOWNZ80_CONDITION_NOT_ZERO = 0,
	CLOWNZ80_CONDITION_ZERO = 1,
	CLOWNZ80_CONDITION_NOT_CARRY = 2,
	CLOWNZ80_CONDITION_CARRY = 3,
	CLOWNZ80_CONDITION_PARITY_OVERFLOW = 4,
	CLOWNZ80_CONDITION_PARITY_EQUALITY = 5,
	CLOWNZ80_CONDITION_PLUS = 6,
	CLOWNZ80_CONDITION_MINUS = 7
} ClownZ80_Condition;

typedef enum ClownZ80_RegisterMode
{
	CLOWNZ80_REGISTER_MODE_HL,
	CLOWNZ80_REGISTER_MODE_IX,
	CLOWNZ80_REGISTER_MODE_IY
} ClownZ80_RegisterMode;

typedef struct ClownZ80_InstructionMetadata
{
	/* These three are actually enums packed into chars to save RAM. */
	cc_u8l opcode;      /* ClownZ80_Opcode */
	cc_u8l operands[2]; /* ClownZ80_Operand */
	cc_u8l condition;   /* ClownZ80_Condition */
	cc_u8l embedded_literal;
	cc_bool has_displacement;
} ClownZ80_InstructionMetadata;

typedef struct ClownZ80_State
{
	cc_u8l register_mode; /* ClownZ80_RegisterMode */
	cc_u16l cycles;
	cc_u16l program_counter;
	cc_u16l stack_pointer;
	cc_u8l a, f, b, c, d, e, h, l;
	cc_u8l a_, f_, b_, c_, d_, e_, h_, l_; /* Backup registers. */
	cc_u8l ixh, ixl, iyh, iyl;
	cc_u8l r, i;
	cc_bool interrupts_enabled;
	cc_bool interrupt_pending;
} ClownZ80_State;

typedef struct ClownZ80_ReadAndWriteCallbacks
{
	cc_u16f (*read)(void *user_data, cc_u16f address);
	void (*write)(void *user_data, cc_u16f address, cc_u16f value);
	CC_ATTRIBUTE_PRINTF(2, 3) void (*log)(void *user_data, const char* const format, ...);
	const void *user_data;
} ClownZ80_ReadAndWriteCallbacks;

void ClownZ80_Constant_Initialise(void);
void ClownZ80_State_Initialise(ClownZ80_State *state);
void ClownZ80_Reset(ClownZ80_State *state);
void ClownZ80_Interrupt(ClownZ80_State *state, cc_bool assert_interrupt);
cc_u16f ClownZ80_DoCycle(ClownZ80_State *state, const ClownZ80_ReadAndWriteCallbacks *callbacks);

#endif /* CLOWNZ80_H */
